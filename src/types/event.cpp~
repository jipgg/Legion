#include "builtin.h"
#include "lua_util.h"
#include "lua_atom.h"
#include "lua_event.h"
namespace bi = builtin;
namespace tn = bi::tname;
using event = lua_event;

static int ctor(lua_State* L) {
    create<event>(L, L);
    return 1;
}


static int namecall(lua_State* L) {
    int atom;
    auto& r = check<event>(L, 1); 
    lua_namecallatom(L, &atom);
    using la = lua_atom;
    switch (static_cast<la>(atom)) {
        case la::connect: {
            print("hmm", luaL_typename(L, 1), luaL_typename(L, 2));
            if (not lua_isfunction(L, 2)) return err_invalid_type(L);
            lua_pushvalue(L, 2);
            r.connect();
            return 0;
        }
        default:
        return err_invalid_method(L, tn::event);
    }
}

int builtin::class_event(lua_State* L) {
    if (luaL_newmetatable(L, metatable_name<event>())) {
        const luaL_Reg lib[] = {
            {"__namecall", namecall},
            {nullptr, nullptr}
        };
        luaL_register(L, nullptr, lib);
        lua_pushstring(L, tn::event);
        lua_setfield(L, -2, bi::metamethod::type);
        lua_pop(L, 1);
    }
    lua_pushcfunction(L, ctor, tn::event);
    return 1;
}
